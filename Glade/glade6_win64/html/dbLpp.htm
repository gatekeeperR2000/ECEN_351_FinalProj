<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><!-- #BeginTemplate "/Templates/glade.dwt" --><!-- DW6 -->
  <head>
    <!-- #BeginEditable "doctitle" --> 
    <title>Glade Reference Manual</title>
    <link href="CSS Docs/shadowHeading1.css" rel="stylesheet" type="text/css">
    <!-- #EndEditable -->
    <meta http-equiv="Content-Type"
    content="text/html; charset=iso-8859-1">
    <style type="text/css">
    body,td,th {
      font-family: Arial, Helvetica, sans-serif;
    }
    </style>
  </head>

  <body bgcolor="#FFFFFF">
    <div align="left"><img src="images/canvasview" width="32" height="32" align="right"><br>
    </div>
    <div align="left">
      <p align="left"><font face="Arial, Helvetica, sans-serif"><b>
        <font size="4">
          Glade Reference
        </font></b>
      </font></p>
      <hr>

      <!-- #BeginEditable "text" -->
    <h2><font face="Arial, Helvetica, sans-serif">
      lpp (formerly dbLpp)
    </font></h2>

    <p>
      A lpp object forms a layer-purpose pair. It manages objects in a tree structure for fast spatial searching.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      lpp::lpp(<a href="cellview.htm">cellView </a>*cv)
    </font></h4>

    <p>
      Constructs a lpp object with master cellView <em>cv</em>.
    </p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      lpp::lpp(<a href="cellview.htm">int32_t size, cellView </a>*cv)
    </font></h4>

    <p>
      Constructs a lpp object with master cellView <em>cv</em>, with expected size of <em>size</em>.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      lpp::layerName(const char *name)
    </font></h4>

    <p>
      Sets the layer name of the lpp.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      const char * lpp::layerName()
    </font></h4>

    <p>
      Gets the lpp&#39;s layer name.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      lpp::purpose(const char *name)
    </font></h4>

    <p>
      Sets the purpose name of the lpp.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      const char * lpp::purpose()
    </font></h4>

    <p>
      Gets the lpp&#39;s purpose name.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      lpp::layerNum(int16_t layerNum)
    </font></h4>

    <p>
      Sets the layer number of the lpp.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      int16_t lpp::layerNum()
    </font></h4>

    <p>
      Gets the lpp&#39;s layer number.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      int32_t lpp::numShapes()
    </font></h4>

    <p>
      Gets the number of shapes in this lpp.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      cellView * lpp::cv()
    </font></h4>

    <p>
      Get the cellView for this lpp.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      Rect  lpp::bBox()
    </font></h4>

    <p>
      Get the bounding box of all shapes in this lpp.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      lpp::bBox(Rect box)
    </font></h4>

    <p>
      Set the bounding box of the lpp.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      lpp::optimiseTree()
    </font></h4>

    <p>
      Optimise the lpp. Must be carried out after adding objects.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      lpp::updateTree(dbObj *obj)
    </font></h4>

    <p>
      Update the lpp for an object
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      int32_t size = lpp::size()
    </font></h4>

    <p>
      Gets the size (number of items) of the lpp
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      <a href="dbObjList.htm">dbObjList</a>&lt;<a href="dbObj.htm">dbObj</a>&gt; * lpp::getOverlaps (<a href="Rect.htm">Rect </a>searchRect, int32_t filterSize=0)
    </font></h4>

    <p>
      Search the lpp for shapes overlapping the search rectangle <i>searchRect</i>. 
      If <i>filterSize</i> is non-zero, only shapes with a width and height greater 
      than <i>filterSize</i> are reported.Note this function creates a new 
      list, and therefore it is better to use the following two functions:
    </p>

    <p>&nbsp;</p>
    
    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      list = lpp::getOverlaps_py (<a href="Rect.htm">Rect </a>searchRect, int32_t filterSize=0)
    </font></h4>

    <p>
      As above, but returns a Python list.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      lpp::getOverlaps (<a href="dbObjList.htm">dbObjList</a>&lt;<a href="dbObj.htm">dbObj</a>&gt; *list, <a href="Rect.htm">Rect </a>searchRect, int32_t filterSize=0)
    </font></h4>

    <p>
      As getOverlaps, but shapes are appended to the existing <i>list</i>.
    </p>
    
    <p>&nbsp;</p>

    <h2><font face="Arial, Helvetica, sans-serif">
      Iterator
    </font></h2>

    <p> 
      An iterator to allow traversing the objects in the lpp using Python.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      iter objIterator(lpp *lp)
    </font></h4>

    <p>
      Initialises the <a href="dbObj.htm">dbObj</a> iterator <em>iter</em> for the lpp <em>lp</em>. For example:
    </p>

    <blockquote>
      <pre>
          iter = objIterator(lpp)
          while not iter.end() :
            obj = iter.value()
            type = obj.objType()
            print(&quot;object type = &quot;, type)
            iter.next()
      </pre>
    </blockquote>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      <a href="dbObj.htm">dbObj </a> * iter.value()
    </font></h4>

    <p>
      Returns the current iterator value.
    </p>

    <p>&nbsp;</p>

    <h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      iter.next()
    </font></h4>

    <p>
      Advances the iterator to the next dbObj.
    </p>

    &nbsp;</p>

    <<h4 class="shadowHeading1"><font face="Arial, Helvetica, sans-serif">
      bool iter.end()
    </font></h4>

    <p>
      Returns false if there are more objects, else returns true if there are no more.
    </p>

    <p>&nbsp;</p>
    <p>&nbsp;</p>

    <!-- #EndEditable --> 
      <p><a href="contents.htm"><font face="Arial, Helvetica, sans-serif">Contents</font></a><font face="Arial, Helvetica, sans-serif">|<a href="subject_index.htm">Index</a></font></p>
      <p><font face="Arial, Helvetica, sans-serif" size="-2">Copyright &copy; Peardrop Design 2024.</font></p>
    </div>
  </body>
<!-- #EndTemplate --></html>
